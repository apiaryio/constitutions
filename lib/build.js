const webpack = require('webpack');
const path = require('path');
const _ = require('lodash');
const fs = require('fs');

const helpers = require('./helpers');
const template = require('./templates');

const styleGuides = helpers.getStyleGuides();

const webpackConfig = {
  entry: [],
  output: {
    path: path.resolve(__dirname, '../build/'),
    filename: 'functions.js',
    library: 'functions',
    // libraryTarget: 'commonjs2'
    // libraryExport: 'validatePrettyPrintedJson_webpack',
    // libraryTarget: 'var',
  },
  target: 'node',
  mode: 'production',
  cache: true,
  optimization: {
    minimize: false,
  },
};

function getEntry(rules) {
  const basePath = path.resolve(__dirname, '../');

  let entryFile = '';
  let exports = '';

  _.each(rules, (rule) => {
    entryFile += '// eslint-disable-next-line max-len, camelcase\n';
    entryFile += `const ${rule.rule.functionName}_webpack = require('./${rule.functionsFile}').${rule.rule.functionName};\n`;
    exports += `  ${rule.rule.functionName}_webpack,\n`;
  });

  entryFile += `\nmodule.exports = {\n${exports}};\n`;

  const entryPath = path.join(basePath, 'entry.js');

  fs.writeFileSync(entryPath, entryFile);

  return entryPath;
}

_.each(styleGuides.rules, (rule) => {
  fs.writeFileSync(`${rule.ruleDir}README.md`, template.generateRule(rule));
});

function getFunction(rule) {
  const fcTemplate = `/*
<%= title %>
<%= intent %>

@targets: <%= allowedTargets %>
@minim: <%= minim %>
*/
function <%= fName %>(data) {
  return functions.<%= fName %>_webpack(data);
}
`;

  return _.template(fcTemplate)({
    title: rule.title,
    intent: rule.intent,
    allowedTargets: (rule.allowedTargets || []).join(', '),
    minim: `${!!rule.minim}`,
    fName: rule.functionName,
  });
}

function getHHRules(rules) {
  const outRules = [];

  _.each(rules, (rule) => {
    _.each(rule.rule.allowedTargets || [], (target) => {
      outRules.push({
        intent: rule.rule.intent,
        ruleName: rule.ruleName,
        functionName: rule.rule.functionName,
        target,
      });
    });
  });

  return outRules;
}


function generateFunctions(wpConfig, rules, cb) {
  const functionsFile = `${wpConfig.output.path}/${wpConfig.output.filename}`;

  if (fs.existsSync(functionsFile)) {
    fs.unlinkSync(functionsFile);
  }

  webpack(wpConfig, (err, stats) => {
    if (err) {
      return cb(err);
    }

    const compileErrors = _.get(stats, 'compilation.errors');

    if (compileErrors) {
      return cb(compileErrors);
    }

    let fctions = '';
    let generated = fs.readFileSync(functionsFile, 'utf8');

    _.each(rules, (rule) => {
      fctions += `${getFunction(rule.rule)}\n`;
    });

    generated = `
${fctions}
/**************************************************************/
/****Generated by WEBPACK**************************************/
/**************************************************************/
${generated}`;

    fs.writeFileSync(functionsFile, generated);

    return cb();
  });
}


const entry = getEntry(styleGuides.rules);

webpackConfig.entry = entry;

fs.writeFileSync(`${path.resolve(__dirname, '../build')}/README.md`, template.generateStyleguide(styleGuides));

fs.writeFileSync(`${path.resolve(__dirname, '../build')}/rules.json`, JSON.stringify(getHHRules(styleGuides.rules), null, 2));

generateFunctions(webpackConfig, styleGuides.rules, (err) => {
  let exitCode = 0;

  if (err) {
    console.error(err);
    exitCode = 1;
  }

  if (fs.existsSync(entry)) {
    fs.unlinkSync(entry);
  }

  if (exitCode === 0) {
    process.exit(0);
  } else {
    process.exit(1);
  }
});
